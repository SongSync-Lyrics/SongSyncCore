"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _song = _interopRequireDefault(require("../chord_sheet/song"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var WHITE_SPACE = /\s/;
var CHORD_LINE_REGEX = /^\s*((([A-G])(#|b)?([^/\s]*)(\/([A-G])(#|b)?)?)(\s|$)+)+(\s|$)+/;
/**
 * Parses a normal chord sheet
 */

var ChordSheetParser = /*#__PURE__*/function () {
  /**
   * Instantiate a chord sheet parser
   * @param {Object} options options
   * @param {boolean} options.preserveWhitespace whether to preserve trailing whitespace for chords
   */
  function ChordSheetParser() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$preserveWhitespa = _ref.preserveWhitespace,
        preserveWhitespace = _ref$preserveWhitespa === void 0 ? true : _ref$preserveWhitespa;

    _classCallCheck(this, ChordSheetParser);

    this.preserveWhitespace = preserveWhitespace === true;
  }
  /**
   * Parses a chord sheet into a song
   * @param {string} chordSheet The ChordPro chord sheet
   * @param {Object} options Optional parser options
   * @param {Song} options.song The {@link Song} to store the song data in
   * @returns {Song} The parsed song
   */


  _createClass(ChordSheetParser, [{
    key: "parse",
    value: function parse(chordSheet) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$song = _ref2.song,
          song = _ref2$song === void 0 ? null : _ref2$song;

      this.initialize(chordSheet, {
        song: song
      });

      while (this.hasNextLine()) {
        var line = this.readLine();
        this.parseLine(line);
      }

      this.endOfSong();
      this.song.finish();
      return this.song;
    }
  }, {
    key: "endOfSong",
    value: function endOfSong() {}
  }, {
    key: "parseLine",
    value: function parseLine(line) {
      this.songLine = this.song.addLine();

      if (line.trim().length === 0) {
        this.chordLyricsPair = null;
      } else {
        this.parseNonEmptyLine(line);
      }
    }
  }, {
    key: "parseNonEmptyLine",
    value: function parseNonEmptyLine(line) {
      this.chordLyricsPair = this.songLine.addChordLyricsPair();

      if (CHORD_LINE_REGEX.test(line) && this.hasNextLine()) {
        var nextLine = this.readLine();
        this.parseLyricsWithChords(line, nextLine);
      } else {
        this.chordLyricsPair.lyrics = "".concat(line);
      }
    }
  }, {
    key: "initialize",
    value: function initialize(document) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$song = _ref3.song,
          song = _ref3$song === void 0 ? null : _ref3$song;

      this.song = song || new _song["default"]();
      this.lines = document.split('\n');
      this.currentLine = 0;
      this.lineCount = this.lines.length;
      this.processingText = true;
    }
  }, {
    key: "readLine",
    value: function readLine() {
      var line = this.lines[this.currentLine];
      this.currentLine += 1;
      return line;
    }
  }, {
    key: "hasNextLine",
    value: function hasNextLine() {
      return this.currentLine < this.lineCount;
    }
  }, {
    key: "parseLyricsWithChords",
    value: function parseLyricsWithChords(chordsLine, lyricsLine) {
      this.processCharacters(chordsLine, lyricsLine);
      this.chordLyricsPair.lyrics += lyricsLine.substring(chordsLine.length);
      this.chordLyricsPair.chords = this.chordLyricsPair.chords.trim();
      this.chordLyricsPair.lyrics = this.chordLyricsPair.lyrics.trim();

      if (!lyricsLine.trim().length) {
        this.songLine = this.song.addLine();
      }
    }
  }, {
    key: "processCharacters",
    value: function processCharacters(chordsLine, lyricsLine) {
      for (var c = 0, charCount = chordsLine.length; c < charCount; c += 1) {
        var chr = chordsLine[c];
        var nextChar = chordsLine[c + 1];
        var isWhiteSpace = WHITE_SPACE.test(chr);
        this.addCharacter(chr, nextChar);
        this.chordLyricsPair.lyrics += lyricsLine[c] || '';
        this.processingText = !isWhiteSpace;
      }
    }
  }, {
    key: "addCharacter",
    value: function addCharacter(chr, nextChar) {
      var isWhiteSpace = WHITE_SPACE.test(chr);

      if (!isWhiteSpace) {
        this.ensureChordLyricsPairInitialized();
      }

      if (!isWhiteSpace || this.shouldAddCharacterToChords(nextChar)) {
        this.chordLyricsPair.chords += chr;
      }
    }
  }, {
    key: "shouldAddCharacterToChords",
    value: function shouldAddCharacterToChords(nextChar) {
      return nextChar && WHITE_SPACE.test(nextChar) && this.preserveWhitespace;
    }
  }, {
    key: "ensureChordLyricsPairInitialized",
    value: function ensureChordLyricsPairInitialized() {
      if (!this.processingText) {
        this.chordLyricsPair = this.songLine.addChordLyricsPair();
        this.processingText = true;
      }
    }
  }]);

  return ChordSheetParser;
}();

var _default = ChordSheetParser;
exports["default"] = _default;