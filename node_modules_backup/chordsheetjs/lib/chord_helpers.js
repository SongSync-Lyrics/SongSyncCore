"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deprecate = deprecate;
exports.internalSwitchModifier = internalSwitchModifier;
exports.isEmptyString = isEmptyString;
exports.keyDown = keyDown;
exports.keyUp = keyUp;
exports.normalize = normalize;
exports.processChord = processChord;
exports.switchModifier = switchModifier;
exports.transpose = transpose;
exports.transposeDown = transposeDown;
exports.transposeUp = transposeUp;
exports.useModifier = useModifier;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var A = 'A'.charCodeAt(0);
var G = 'G'.charCodeAt(0);

function keyChange(key, delta) {
  var charCode;
  charCode = key.toUpperCase().charCodeAt(0);
  charCode += delta;

  if (charCode > G) {
    charCode = A;
  }

  if (charCode < A) {
    charCode = G;
  }

  return String.fromCharCode(charCode);
}

function keyUp(key) {
  return keyChange(key, 1);
}

function keyDown(key) {
  return keyChange(key, -1);
}

function normalize(base, modifier) {
  if (modifier === '#' && /^(B|E)$/.test(base)) {
    return [keyUp(base), null];
  }

  if (modifier === 'b' && /^(C|F)$/.test(base)) {
    return [keyDown(base), null];
  }

  return [base, modifier];
}

function internalSwitchModifier(base, modifier) {
  if (modifier === '#') {
    return [keyUp(base), 'b'];
  }

  if (modifier === 'b') {
    return [keyDown(base), '#'];
  }

  throw new Error("Unexpected modifier ".concat(modifier));
}

function switchModifier(base, modifier) {
  var _normalize = normalize(base, modifier),
      _normalize2 = _slicedToArray(_normalize, 2),
      normalizedBase = _normalize2[0],
      normalizedModifier = _normalize2[1];

  if (modifier) {
    return internalSwitchModifier(normalizedBase, normalizedModifier);
  }

  return [normalizedBase, normalizedModifier];
}

function useModifier(base, modifier, newModifier) {
  if (modifier && modifier !== newModifier) {
    return internalSwitchModifier(base, modifier);
  }

  return [base, modifier];
}

function repeatProcessor(base, modifier, processor, amount) {
  var processedBase = base,
      processedModifier = modifier;

  for (var i = 0; i < amount; i += 1) {
    var _processor = processor(processedBase, processedModifier);

    var _processor2 = _slicedToArray(_processor, 2);

    processedBase = _processor2[0];
    processedModifier = _processor2[1];
  }

  return [processedBase, processedModifier];
}

function transposeUp(base, modifier) {
  var _normalize3 = normalize(base, modifier),
      _normalize4 = _slicedToArray(_normalize3, 2),
      normalizedBase = _normalize4[0],
      normalizedModifier = _normalize4[1];

  if (normalizedModifier === 'b') {
    return [normalizedBase, null];
  }

  if (normalizedModifier === '#') {
    return [keyUp(normalizedBase), null];
  }

  if (/^(B|E)$/.test(normalizedBase)) {
    return [keyUp(normalizedBase), null];
  }

  return [normalizedBase, '#'];
}

function transposeDown(base, modifier) {
  var _normalize5 = normalize(base, modifier),
      _normalize6 = _slicedToArray(_normalize5, 2),
      normalizedBase = _normalize6[0],
      normalizedModifier = _normalize6[1];

  if (normalizedModifier === 'b') {
    return [keyDown(normalizedBase), null];
  }

  if (normalizedModifier === '#') {
    return [normalizedBase, null];
  }

  if (/^(C|F)$/.test(normalizedBase)) {
    return [keyDown(normalizedBase), null];
  }

  return [normalizedBase, 'b'];
}

function transpose(base, modifier, delta) {
  var newBase = base,
      newModifier = modifier;

  if (delta < 0) {
    var _repeatProcessor = repeatProcessor(base, modifier, transposeDown, Math.abs(delta));

    var _repeatProcessor2 = _slicedToArray(_repeatProcessor, 2);

    newBase = _repeatProcessor2[0];
    newModifier = _repeatProcessor2[1];
  } else if (delta > 0) {
    var _repeatProcessor3 = repeatProcessor(base, modifier, transposeUp, delta);

    var _repeatProcessor4 = _slicedToArray(_repeatProcessor3, 2);

    newBase = _repeatProcessor4[0];
    newModifier = _repeatProcessor4[1];
  }

  return useModifier(newBase, newModifier, modifier);
}

function processChord(sourceChord, processor, processorArg) {
  var chord = sourceChord.clone();

  var _processor3 = processor(sourceChord.base, sourceChord.modifier, processorArg);

  var _processor4 = _slicedToArray(_processor3, 2);

  chord.base = _processor4[0];
  chord.modifier = _processor4[1];

  if (sourceChord.bassBase) {
    var _processor5 = processor(sourceChord.bassBase, sourceChord.bassModifier, processorArg);

    var _processor6 = _slicedToArray(_processor5, 2);

    chord.bassBase = _processor6[0];
    chord.bassModifier = _processor6[1];
  }

  return chord;
}

function deprecate(message) {
  try {
    throw new Error("DEPRECATION: ".concat(message));
  } catch (e) {
    if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && typeof process.emitWarning === 'function') {
      process.emitWarning("".concat(message, "\n").concat(e.stack));
    } else {
      console.warn("".concat(message, "\n").concat(e.stack));
    }
  }
}

function isEmptyString(string) {
  return string === null || string === undefined || string === '';
}